@page "/debts"

@using FinLY.Models
@using FinLY.Services
@inject AuthenticationStateService AuthService
@inject IDebtsServices debtsServices
@inject IUserBalanceServicees userBalanceService

@if (AuthService.IsAuthenticated())
{
    <div class="top-nav">
        <div class="dash-left-side">
            <p>Welcome, @userName</p>
        </div>
        <div class="dash-right-side">
            <p>@todayDate</p>
        </div>
    </div>

    <div>
        <div class="debt_container">
            <div class="debt_header">
                @if (!string.IsNullOrEmpty(ErrorMessage))
                {
                    <div class="alert alert-danger">
                        @ErrorMessage
                    </div>
                }
                <h1 class="debt_title">Debts</h1>
                <button class="debt_button" @onclick="ShowAddDebtModal">Add Debts</button>
            </div>
            <div class="filters">
                <div class="filter-buttons">
                </div>
                <div class="search">
                    <input type="text" class="search-input" @bind="searchQuery" @oninput="OnSearchChanged" placeholder="Find Transaction..." />

                    <button class="search-clear-btn" @onclick="ClearSearch">
                        <i class="bi bi-x-circle"></i>
                    </button>

                </div>
            </div>

            <div class="table-container">
                <table class="table">
                    <thead>
                        <tr>
                            <th>Debt Title</th>
                            <th>Total Debt Amount</th>
                            <th>Remaining Amount</th>
                            <th @onclick="SortDebtsByDate" style="cursor: pointer;">
                                Due Date
                                <i class="bi @(isSortDateAscending ? "bi-caret-up-fill" : "bi-caret-down-fill")"></i>
                            </th>

                            <th>Source From</th>
                            <th>Note</th>
                            <th @onclick="SortDebtsByStatus" style="cursor: pointer;">
                                Status
                                <i class="bi @(isSortStatusAscending ? "bi-caret-up-fill" : "bi-caret-down-fill")" style="float: right;"></i>
                            </th>

                            <th>Actions</th>
                        </tr>
                    </thead>

                    <tbody>
                        @foreach (var debt in filteredDebts)
                        {
                            <tr>
                                <td>@debt.DebtTitle</td>
                                <td>@debt.TotalDebtAmount</td>
                                <td>@debt.RemainingAmount</td>
                                <td>@debt.DueDate.ToString("MMMM dd, yyyy")</td>
                                <td>@debt.SourceFrom</td>
                                <td>@debt.Note</td>
                                <td>@debt.DebtStatus</td>
                                <td>
                                    <button class="btn btn-info" @onclick="() => ShowEditDebtOffcanvas(debt)">Edit</button>

                                    @if (debt.DebtStatus != "Paid")
                                    {
                                        <button class="btn btn-primary" @onclick="() => PayDebt(debt)">Pay</button>
                                    }
                                </td>
                            </tr>
                        }
                    </tbody>

                </table>
            </div>
        </div>

        <!-- Add Debt Modal -->
        <div class="modal fade @((isAddDebtModalVisible) ? "show" : "")" tabindex="-1" aria-labelledby="addDebtModalLabel" aria-hidden="true" style="display: @(isAddDebtModalVisible ? "block" : "none")">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="addDebtModalLabel">Add New Debt</h5>
                        <button type="button" class="btn-close" @onclick="HideAddDebtModal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <form @onsubmit="HandleSubmit">
                            <label>Debt Title:</label>
                            <input type="text" @bind="newUserDebt.DebtTitle" class="form-control" required />

                            <label>Total Debt Amount:</label>
                            <input type="number" @bind="newUserDebt.TotalDebtAmount" class="form-control" required />

                            <label>Paid Amount:</label>
                            <input type="number" @bind="newUserDebt.PaidAmount" class="form-control" required />

                            <label>Due Date:</label>
                            <input type="date" @bind="newUserDebt.DueDate" class="form-control" required />

                            <label>Source From:</label>
                            <input type="text" @bind="newUserDebt.SourceFrom" class="form-control" required />

                            <label>Note:</label>
                            <textarea @bind="newUserDebt.Note" class="form-control" rows="3"></textarea>

                            <button type="submit" class="btn btn-success">Add Debt</button>
                        </form>
                    </div>
                </div>
            </div>
        </div>

        <!-- Offcanvas for editing debt -->
        <div class="offcanvas offcanvas-end @((isEditDebtVisible) ? "show" : "")" tabindex="-1" id="editDebtOffcanvas" aria-labelledby="editDebtOffcanvasLabel" style="display: @(isEditDebtVisible ? "block" : "none")">
            <div class="offcanvas-header">
                <h5 id="editDebtOffcanvasLabel">Edit Debt</h5>
                <button type="button" class="btn-close" data-bs-dismiss="offcanvas" @onclick="HideEditDebtOffcanvas" aria-label="Close"></button>
            </div>
            <div class="offcanvas-body">
                <form @onsubmit="HandleEditSubmit">
                    <label>Debt Title:</label>
                    <input type="text" @bind="debtToEdit.DebtTitle" class="form-control" required />

                    <label>Total Debt Amount:</label>
                    <input type="number" @bind="debtToEdit.TotalDebtAmount" class="form-control" required />

                    <label>Paid Amount:</label>
                    <input type="number" @bind="debtToEdit.PaidAmount" class="form-control" required />

                    <label>Due Date:</label>
                    <input type="date" @bind="debtToEdit.DueDate" class="form-control" required />

                    <label>Source From:</label>
                    <input type="text" @bind="debtToEdit.SourceFrom" class="form-control" required />

                    <label>Note:</label>
                    <textarea @bind="debtToEdit.Note" class="form-control" rows="3"></textarea>

                    <button type="submit" class="btn btn-success">Save Changes</button>
                    <button type="button" class="btn btn-danger" @onclick="CancelEdit">Cancel</button>
                </form>
            </div>
        </div>
    </div>

}
@code {
    private string userName;
    private string todayDate;
    private UserDebt newUserDebt = new UserDebt();
    private List<UserDebt> allUserDebts = new List<UserDebt>();
    private UserDebt debtToEdit = new UserDebt(); // Initialize the object to avoid null references.
    private bool isAddDebtModalVisible = false;
    private bool isEditDebtVisible = false;
    private string ErrorMessage { get; set; } = string.Empty;
    private bool isSortAscending = true; // Toggle for sorting order
    private bool isSortStatusAscending = true; // Toggle for sorting status order
    private bool isSortDateAscending = true; // This will track the sort order for due date
    private string searchQuery = string.Empty; // Added for search functionality
    private List<UserDebt> filteredDebts = new List<UserDebt>(); // Initialize to avoid null reference



    protected override async Task OnInitializedAsync()
    {
        var user = AuthService.GetAuthenticatedUser();
        if (user != null)
        {
            userName = user.UserName;
            await LoadDebts();
        }
        else
        {
            Console.WriteLine("User not authenticated.");
        }

        todayDate = DateTime.Now.ToString("MMMM dd, yyyy");
    }

    private async Task HandleSubmit()
    {
        var user = AuthService.GetAuthenticatedUser();
        if (user != null)
        {
            newUserDebt.UserId = user.UserId;
            newUserDebt.DebtStatus = "Pending";

            try
            {
                await debtsServices.AddDebtAsync(newUserDebt);

                decimal totalDebtAmount = newUserDebt.TotalDebtAmount;
                var allDebts = await debtsServices.GetDebtsByUserIdAsync(user.UserId);
                totalDebtAmount = allDebts.Sum(debt => debt.TotalDebtAmount);


                var userBalance = await userBalanceService.GetUserBalanceAsync(user.UserId);
                decimal availableBalanceWithDebt = userBalance.AvailableBalance + totalDebtAmount - newUserDebt.PaidAmount;
                await userBalanceService.UpdateUserBalanceAsync(user.UserId, availableBalanceWithDebt, "Debts");


                newUserDebt = new UserDebt();
                await LoadDebts();
                HideAddDebtModal();

            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error adding debt: {ex.Message}");
            }
        }
    }

    private async Task LoadDebts()
    {
        var user = AuthService.GetAuthenticatedUser();
        if (user != null)
        {
            allUserDebts = await debtsServices.GetDebtsByUserIdAsync(user.UserId);
            ApplyFilters(); // Apply filters after loading debts
        }
    }

    private async Task PayDebt(UserDebt debt)
    {
        try
        {
            // Clear previous error message
            ErrorMessage = string.Empty;

            // Get the user's available balance with debts
            var userBalance = await userBalanceService.GetUserBalanceAsync(debt.UserId);

            // Check if AvailableBalancewithDebt is being correctly calculated
            Console.WriteLine($"Available balance with debts: {userBalance.AvailableBalancewithDebt}");

            // Ensure debt.TotalDebtAmount is correctly set (check for any negative or zero amounts)
            if (debt.TotalDebtAmount <= 0)
            {
                ErrorMessage = "Error: Debt amount must be greater than zero.";
                return;
            }

            // Check if the debt amount is less than or equal to the available balance
            if (debt.TotalDebtAmount <= userBalance.AvailableBalance)
            {
                // Proceed with paying the debt
                debt.RemainingAmount = 0;
                debt.PaidAmount = debt.TotalDebtAmount;
                debt.DebtStatus = "Paid";

                // Update debt information in the debts service
                await debtsServices.UpdateDebtAsync(debt);

                // Update the user balance
                await userBalanceService.UpdateTotalClearedDebtAmountAsync(debt.UserId, userBalance.DebtClearedAmount);
                // Calculate the total cleared debt amount (sum of PaidAmounts where DebtStatus is "Paid")
                var allDebts = await debtsServices.GetDebtsByUserIdAsync(debt.UserId);
                decimal totalClearedDebtAmount = allDebts.Where(d => d.DebtStatus == "Paid").Sum(d => d.PaidAmount);

                // Update the user balance with the total cleared debt amount
                await userBalanceService.UpdateTotalClearedDebtAmountAsync(debt.UserId, totalClearedDebtAmount);

                // Reload debts after payment
                await LoadDebts();
            }
            else
            {
                // Set the error message if debt cannot be paid
                ErrorMessage = "Error: Insufficient funds to pay the debt.";
            }
        }
        catch (Exception ex)
        {
            // Set the error message for unexpected errors
            ErrorMessage = $"Error paying debt: {ex.Message}";
        }
    }



    private void ShowEditDebtOffcanvas(UserDebt debt)
    {
        // Initialize debtToEdit with the selected debt's data to avoid null reference.
        debtToEdit = new UserDebt
            {
                DebtTitle = debt.DebtTitle,
                TotalDebtAmount = debt.TotalDebtAmount,
                PaidAmount = debt.PaidAmount,
                RemainingAmount = debt.RemainingAmount, // Ensure to include all fields you want to edit.
                DueDate = debt.DueDate,
                SourceFrom = debt.SourceFrom,
                Note = debt.Note,
                DebtStatus = debt.DebtStatus
            };

        isEditDebtVisible = true; // Show the offcanvas
    }

    private void HideEditDebtOffcanvas()
    {
        isEditDebtVisible = false; // Hide the offcanvas
    }

    private async Task HandleEditSubmit()
    {
        try
        {
            if (debtToEdit != null)
            {
                // Update the debt
                await debtsServices.UpdateDebtAsync(debtToEdit);

                // Recalculate and update the user balance
                var user = AuthService.GetAuthenticatedUser();
                if (user != null)
                {
                    // Update the user's balance by including the debt change
                    await userBalanceService.UpdateUserBalanceAsync(user.UserId, debtToEdit.TotalDebtAmount, "InFlow");

                    // Optionally, if the total debt is reduced (or cleared), update with "OutFlow"
                    if (debtToEdit.DebtStatus == "Paid")
                    {
                        await userBalanceService.UpdateUserBalanceAsync(user.UserId, debtToEdit.PaidAmount, "OutFlow");
                    }
                }

                debtToEdit = null;
                await LoadDebts();
                HideEditDebtOffcanvas(); // Hide the offcanvas after saving
            }
            else
            {
                Console.WriteLine("Debt to edit is not initialized.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error editing debt: {ex.Message}");
        }
    }


    private void CancelEdit()
    {
        debtToEdit = null;
        HideEditDebtOffcanvas(); // Hide offcanvas without saving
    }

    private void ShowAddDebtModal()
    {
        isAddDebtModalVisible = true;
    }

    private void HideAddDebtModal()
    {
        isAddDebtModalVisible = false;
    }


    private void ApplyFilters()
    {
        // Apply the search filter based on debt title
        filteredDebts = allUserDebts
            .Where(debt => string.IsNullOrEmpty(searchQuery) || debt.DebtTitle.Contains(searchQuery, StringComparison.OrdinalIgnoreCase))
            .ToList();

        // Apply sorting by due date
        filteredDebts = isSortDateAscending
            ? filteredDebts.OrderBy(debt => debt.DueDate).ToList() // Sort by date ascending
            : filteredDebts.OrderByDescending(debt => debt.DueDate).ToList(); // Sort by date descending

        // Apply sorting by debt status
        filteredDebts = isSortStatusAscending
            ? filteredDebts.OrderBy(debt => debt.DebtStatus).ToList()
            : filteredDebts.OrderByDescending(debt => debt.DebtStatus).ToList();

        StateHasChanged(); // Refresh the UI with updated filtered list
    }



    private void SortDebtsByDate()
    {
        // Toggle the sorting order for date
        isSortDateAscending = !isSortDateAscending;
        ApplyFilters(); // Apply filters after sorting by date
    }

    private void SortDebtsByStatus()
    {
        // Toggle the sorting order for status
        isSortStatusAscending = !isSortStatusAscending;
        ApplyFilters(); // Apply filters after sorting by status
    }

    // Add event handler to update the search query and apply filters
    private void OnSearchChanged(ChangeEventArgs e)
    {
        searchQuery = e.Value.ToString(); // Update search query with the new value
        ApplyFilters(); // Reapply filters with the updated search query
    }


    private void ClearSearch()
    {
        searchQuery = string.Empty;  // Clear search query
        ApplyFilters(); // Reapply filters to show all debts
    }


}

